## Layouts with Nested Routing

### What is a Layout in React Router?

A layout is a component that wraps multiple pages to provide a consistent UI — for example:

- Navbar
- Sidebar
- Footer
- Common styles

Instead of duplicating those in every page, we define them once in a parent route and render the child pages via `<Outlet />`.

### How Nested Routing Powers Layouts

Nested routing means:

- A parent route renders the layout.
- A child route renders inside the layout via `<Outlet />`.
- The layout stays in place when navigating between child routes.

**Example:**

- `/dashboard` → DashboardLayout + DashboardHome
- `/dashboard/settings` → DashboardLayout + SettingsPage

Here, `DashboardLayout` is always visible, only the `<Outlet />` content changes.

### Declarative Mode — Layout Example

```jsx
import { BrowserRouter, Routes, Route, Link, Outlet } from 'react-router-dom';

function DashboardLayout() {
  return (
    <div>
      <header>
        <h1>Dashboard</h1>
        <nav>
          <Link to="">Home</Link> | <Link to="settings">Settings</Link>
        </nav>
      </header>
      <main>
        <Outlet /> {/* Child routes render here */}
      </main>
    </div>
  );
}

function DashboardHome() {
  return <h2>Dashboard Home</h2>;
}

function Settings() {
  return <h2>Settings Page</h2>;
}

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="dashboard" element={<DashboardLayout />}>
          <Route index element={<DashboardHome />} />
          <Route path="settings" element={<Settings />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
```

**How it works:**

- `DashboardLayout` is rendered at `/dashboard`.
- `<Outlet />` is replaced with the child route (`DashboardHome` or `Settings`).
- The layout never unmounts between child route navigations.

### Data Mode — Layout Example

```jsx
import {
  createBrowserRouter,
  RouterProvider,
  Link,
  Outlet,
} from 'react-router-dom';

function DashboardLayout() {
  return (
    <div>
      <header>
        <h1>Dashboard</h1>
        <nav>
          <Link to="">Home</Link> | <Link to="settings">Settings</Link>
        </nav>
      </header>
      <main>
        <Outlet />
      </main>
    </div>
  );
}

function DashboardHome() {
  return <h2>Dashboard Home</h2>;
}

function Settings() {
  return <h2>Settings Page</h2>;
}

const router = createBrowserRouter([
  {
    path: 'dashboard',
    element: <DashboardLayout />,
    children: [
      { index: true, element: <DashboardHome /> },
      { path: 'settings', element: <Settings /> },
    ],
  },
]);

export default function App() {
  return <RouterProvider router={router} />;
}
```

**How it works:**

- In Data Mode, `children` defines nested routes.
- The `<Outlet />` in `DashboardLayout` is replaced by the matched child element.

### Benefits of Layout + Nested Routing

- ✅ Reusable structure — Define headers, navbars, and sidebars once.
- ✅ Better UX — Layout stays mounted, only child content updates.
- ✅ Scalable — Multiple layouts can exist for different sections (e.g., admin vs public).
- ✅ Integrates with loaders — In Data Mode, you can load layout-level data (like user info) in the parent loader so all child routes get it.
