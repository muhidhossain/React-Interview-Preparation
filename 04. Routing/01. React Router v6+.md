## React Router v6+

### Definition

React Router v6+ is a client-side routing library that maps URLs to React components. It uses the HTML5 History API to update the browser's address bar and render the correct UI without a full page refresh.

### Key Features in v6+

Compared to older versions (v5, v4), v6 introduced major improvements:

- **Component-based routing**: Routes are declared inside a `<Routes>` component, and each route is defined using a `<Route>` element.
- **`element` instead of `component` or `render` props**: You now pass the component as JSX via the `element` prop:

  ```jsx
  <Route path="/about" element={<About />} />
  ```

- **Nested routes**: Routes can be nested inside each other, matching URL segments.
- **Hooks for navigation & params**:
  - `useNavigate()` → programmatic navigation
  - `useParams()` → read dynamic route params
  - `useLocation()` → access location info
  - `useSearchParams()` → handle query string
- **Better route matching**: v6 matches routes exactly by default and uses a ranking system for the best match.
- **Data APIs (v6.4+)**: Loader and action functions can fetch data before rendering.

### Basic Example

```jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
```

**Here:**

- `/` → Renders `<Home />`
- `/about` → Renders `<About />`

### Common Uses

- **Single Page Applications (SPA)**: Provide multiple views without reloading the browser.
- **Dynamic Routing**: Render content based on URL parameters:

  ```jsx
  <Route path="/users/:id" element={<UserProfile />} />
  ```

  Access `id` with:

  ```js
  const { id } = useParams();
  ```

- **Programmatic Navigation**: Redirect users after actions:

  ```js
  const navigate = useNavigate();
  navigate('/dashboard');
  ```

- **Nested Layouts**: Shared layouts (like navbars) with nested child routes.
- **Authentication Routing**: Restrict access to certain pages:

  ```jsx
  <Route path="/dashboard" element={isLoggedIn ? <Dashboard /> : <Login />} />
  ```

### Comparison Table — Declarative vs Data Mode

| Feature                     | Declarative Mode                             | Data Mode                                          |
| --------------------------- | -------------------------------------------- | -------------------------------------------------- |
| Syntax                      | JSX `<Routes>` & `<Route>` inside components | Route config array passed to `createBrowserRouter` |
| Location of routes          | Inside the render tree                       | Outside the render tree                            |
| Readability                 | More visual for small apps                   | More structured for large apps                     |
| Scalability                 | Can get messy in large apps                  | Easy to manage in large apps                       |
| Data APIs (loaders/actions) | Not supported directly                       | Fully supported                                    |
| SSR readiness               | Manual work needed                           | Designed for SSR & streaming                       |
| Best for                    | Simple SPAs, UI-driven routing               | Data-driven apps, SSR, larger codebases            |

**In short:**

- Use **Declarative mode** if your app is small and routing is simple.
- Use **Data mode** if you want a centralized route definition, SSR, or you’re using loaders/actions.
