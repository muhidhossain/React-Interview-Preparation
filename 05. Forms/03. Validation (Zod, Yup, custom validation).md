## Validation (Zod, Yup, custom validation)

### Why Validation Matters in React Forms

Validation ensures that user input meets certain rules before being processed or submitted.

**Typical goals:**

- Prevent invalid data from being sent to the backend.
- Give users clear error messages.
- Improve UX by catching mistakes early.

In React, you can validate form inputs in three main ways:

- Using schema-based libraries like Zod or Yup.
- Writing your own custom validation logic.

---

### Zod Validation in React

Zod is a TypeScript-first schema validation library. It works well with react-hook-form and is highly type-safe.

**Example with react-hook-form + Zod:**

```tsx
import React from 'react';
import { useForm } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

// 1. Define schema
const schema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email'),
  age: z.number().min(18, 'Must be at least 18'),
});

// 2. Infer TypeScript type from schema
type FormData = z.infer<typeof schema>;

export default function ZodForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<FormData>({
    resolver: zodResolver(schema),
  });

  const onSubmit = (data: FormData) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('name')} placeholder="Name" />
      {errors.name && <p>{errors.name.message}</p>}

      <input {...register('email')} placeholder="Email" />
      {errors.email && <p>{errors.email.message}</p>}

      <input
        type="number"
        {...register('age', { valueAsNumber: true })}
        placeholder="Age"
      />
      {errors.age && <p>{errors.age.message}</p>}

      <button type="submit">Submit</button>
    </form>
  );
}
```

**Pros:**

- Strong TypeScript support.
- Automatic type inference.
- Good integration with react-hook-form.

---

### Yup Validation in React

Yup is another popular schema-based validation library, but it's JavaScript-first (TypeScript support is possible but not as tight as Zod).

**Example with react-hook-form + Yup:**

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';

// 1. Define schema
const schema = yup.object().shape({
  name: yup.string().min(2, 'Name must be at least 2 characters').required(),
  email: yup.string().email('Invalid email').required(),
  age: yup.number().min(18, 'Must be at least 18').required(),
});

type FormData = {
  name: string,
  email: string,
  age: number,
};

export default function YupForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm <
  FormData >
  {
    resolver: yupResolver(schema),
  };

  const onSubmit = (data: FormData) => console.log(data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('name')} placeholder="Name" />
      {errors.name && <p>{errors.name.message}</p>}

      <input {...register('email')} placeholder="Email" />
      {errors.email && <p>{errors.email.message}</p>}

      <input
        type="number"
        {...register('age', { valueAsNumber: true })}
        placeholder="Age"
      />
      {errors.age && <p>{errors.age.message}</p>}

      <button type="submit">Submit</button>
    </form>
  );
}
```

**Pros:**

- Very popular and mature.
- Lots of examples and community support.
- Flexible validation rules.

**Cons:**

- Less TypeScript inference compared to Zod.

---

### Custom Validation in React

Sometimes, you donâ€™t want an external library. You can write validation manually.

**Example using react-hook-form without schema:**

```jsx
import React from "react";
import { useForm } from "react-hook-form";

type FormData = {
	name: string;
	email: string;
	age: number;
};

export default function CustomValidationForm() {
	const { register, handleSubmit, formState: { errors } } = useForm<FormData>();

	const onSubmit = (data: FormData) => console.log(data);

	return (
		<form onSubmit={handleSubmit(onSubmit)}>
			<input
				{...register("name", {
					required: "Name is required",
					minLength: { value: 2, message: "Name must be at least 2 characters" },
				})}
				placeholder="Name"
			/>
			{errors.name && <p>{errors.name.message}</p>}

			<input
				{...register("email", {
					required: "Email is required",
					pattern: { value: /^[^\s@]+@[^\s@]+\.[^\s@]+$/, message: "Invalid email" },
				})}
				placeholder="Email"
			/>
			{errors.email && <p>{errors.email.message}</p>}

			<input
				type="number"
				{...register("age", {
					required: "Age is required",
					min: { value: 18, message: "Must be at least 18" },
				})}
				placeholder="Age"
			/>
			{errors.age && <p>{errors.age.message}</p>}

			<button type="submit">Submit</button>
		</form>
	);
}
```

**Pros:**

- No external dependencies.
- Full control over rules.
- Great for small forms.

**Cons:**

- More boilerplate for complex forms.
- No shared schema between frontend/backend.

---

### When to Use Which

| Approach          | Best For                                                   |
| ----------------- | ---------------------------------------------------------- |
| Zod               | TypeScript-heavy projects needing type inference           |
| Yup               | Projects with existing Yup usage or JS focus               |
| Custom Validation | Small forms, one-off validations, avoiding extra libraries |
