## Avoiding unnecessary re-renders

Avoiding unnecessary re-renders in React is all about making sure components only re-render when their data or props actually change.
If you don’t manage this well, React will repeatedly re-run the rendering process, which can slow down your app — especially in large UIs.

---

### Here’s the breakdown:

#### Understand why re-renders happen

A React component will re-render when:

- Its state changes (`useState`, `this.setState` in class components)
- Its props change (even if the new value is the same but passed as a new reference)
- Its parent re-renders (causing children to re-render too, unless prevented)

---

### Techniques to prevent unnecessary re-renders

#### a) Use React.memo for functional components

`React.memo` is a higher-order component that memoizes the rendered output and skips re-rendering if props are shallowly equal.

```jsx
import React from 'react';

const Child = React.memo(function Child({ value }) {
  console.log('Child re-rendered');
  return <div>{value}</div>;
});

export default function App() {
  const [count, setCount] = React.useState(0);
  return (
    <>
      <Child value="Static value" />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </>
  );
}
```

Without `React.memo`, `Child` would re-render every time `App` re-renders, even if its value didn’t change.

---

#### b) Memoize expensive calculations with useMemo

Prevents recalculating values unless dependencies change.

```jsx
const expensiveValue = useMemo(() => {
  console.log('Expensive calc');
  return data.filter((item) => item.active);
}, [data]);
```

---

#### c) Memoize functions with useCallback

Passing new function references can cause re-renders in child components.
`useCallback` returns a memoized version of the function.

```jsx
const handleClick = useCallback(() => {
  console.log('Clicked');
}, []);
```

---

#### d) Avoid creating objects/arrays inline in props

Inline objects/arrays create new references every render, causing children to re-render.

❌ **Bad:**

```jsx
<Child data={{ name: 'John' }} />
```

✅ **Good:**

```jsx
const userData = useMemo(() => ({ name: 'John' }), []);
<Child data={userData} />;
```

---

#### e) Split components

Break large components into smaller ones so only the necessary parts re-render when state changes.

---

#### f) Avoid unnecessary state

If a value can be computed from props or other state, don’t store it as a separate piece of state — this reduces the number of updates.

---

#### g) Use key properly

An unstable or changing key can cause React to unmount/remount instead of reusing components.

---

### Common pitfalls that trigger unnecessary re-renders

- Inline functions/objects in props without memoization
- Updating state with the same value
- Overusing context (every context value change triggers all consumers)
- Not using `React.memo` or `useCallback` for stable references

---

### Summary rule:

Keep references stable, keep state minimal, and use memoization where it makes sense. That way, React only re-renders when something actually changes.
