## Memoization (React.memo, useMemo, useCallback)

Memoization is an optimization technique where we store ("cache") the result of an expensive calculation or component rendering and reuse it when the same inputs occur again — instead of recalculating or re-rendering.

In React, memoization helps:

- Avoid unnecessary re-renders.
- Improve performance when working with expensive computations or large components.

### React.memo

`React.memo` is a Higher Order Component (HOC) that wraps a functional component and prevents it from re-rendering if its props haven’t changed.

**Example:**

```jsx
import React, { useState } from 'react';

const Child = React.memo(({ name }) => {
  console.log('Child rendered');
  return <h2>Hello {name}</h2>;
});

export default function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <Child name="Muhid" />
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**Explanation:**

- Without `React.memo`, `Child` would re-render every time `App` re-renders (even if `name` didn’t change).
- With `React.memo`, `Child` only re-renders when `name` changes.

### useMemo

`useMemo` memoizes a computed value. It recalculates only when dependencies change.

**Example:**

```jsx
import React, { useState, useMemo } from 'react';

export default function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  const expensiveCalculation = (num) => {
    console.log('Calculating...');
    for (let i = 0; i < 1000000000; i++) {} // Simulate heavy work
    return num * 2;
  };

  const doubled = useMemo(() => expensiveCalculation(count), [count]);

  return (
    <div>
      <h2>Count: {count}</h2>
      <p>Double: {doubled}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <input value={text} onChange={(e) => setText(e.target.value)} />
    </div>
  );
}
```

**Explanation:**

- Without `useMemo`, `expensiveCalculation` runs on every re-render (even when only `text` changes).
- With `useMemo`, it only runs when `count` changes.

### useCallback

`useCallback` memoizes a function so that its reference doesn’t change unless dependencies change. This is important when passing callbacks to memoized child components to prevent unnecessary re-renders.

**Example:**

```jsx
import React, { useState, useCallback } from 'react';

const Child = React.memo(({ handleClick }) => {
  console.log('Child rendered');
  return <button onClick={handleClick}>Click Me</button>;
});

export default function App() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    console.log('Button clicked');
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <Child handleClick={handleClick} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**Explanation:**

- Without `useCallback`, `handleClick` gets a new reference on every render, causing `Child` to re-render even when props are the same.
- With `useCallback`, the function reference stays the same unless dependencies change.

### When to Use Which

| Hook / HOC  | What It Memoizes   | Use Case                                                      |
| ----------- | ------------------ | ------------------------------------------------------------- |
| React.memo  | Entire component   | Prevents re-renders when props don’t change                   |
| useMemo     | Computed value     | Avoid recalculating expensive values                          |
| useCallback | Function reference | Prevents child re-renders due to changing function references |
