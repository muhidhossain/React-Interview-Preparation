## SSR, SSG, ISR in Next.js

### Why These Matter

These are data fetching & rendering strategies that control when and where HTML is generated for your React app.

They affect:

- Performance (Time to First Byte, SEO)
- Freshness of data
- Server load
- User experience

---

### Definitions

#### A. SSR — Server-Side Rendering

**When:** HTML is generated on each request at runtime.
**Where:** On the server.
**Next.js API:** `getServerSideProps()`

**Flow:**

1. User requests a page.
2. Server runs `getServerSideProps()` to fetch data.
3. HTML is rendered on the server with data.
4. Browser receives fully rendered HTML, then React hydrates it.

**Pros:**

- Always fresh data.
- Great for SEO on dynamic pages.

**Cons:**

- Slower than static pages (server does the work every time).
- Higher server costs.

**Example:**

```js
export async function getServerSideProps() {
  const res = await fetch('https://api.example.com/posts');
  const posts = await res.json();
  return { props: { posts } };
}
```

---

#### B. SSG — Static Site Generation

**When:** HTML is generated at build time.
**Where:** During build/deploy process.
**Next.js API:** `getStaticProps()`

**Flow:**

1. Build process fetches data.
2. HTML files are generated and stored on CDN.
3. Every user gets the same pre-rendered HTML.

**Pros:**

- Very fast (served from CDN).
- No server processing per request.

**Cons:**

- Data can become stale until you rebuild.
- Not suitable for highly dynamic content.

**Example:**

```js
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/posts');
  const posts = await res.json();
  return { props: { posts } };
}
```

---

#### C. ISR — Incremental Static Regeneration

**When:** HTML is generated at build time, but can be re-generated in the background after a certain time.
**Where:** On the server/CDN edge when a user requests the page after the revalidation period.
**Next.js API:** `getStaticProps()` with `revalidate` option.

**Flow:**

1. At build, static HTML is generated.
2. First request after revalidate period triggers a background regeneration.
3. Users keep getting the old version until new HTML is ready, then future users get the updated version.

**Pros:**

- Fast like SSG.
- Can keep data reasonably fresh without rebuilding the whole site.

**Cons:**

- Still not real-time.
- Slight complexity in caching logic.

**Example:**

```js
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/posts');
  const posts = await res.json();
  return {
    props: { posts },
    revalidate: 60, // seconds
  };
}
```

---

### Quick Comparison Table

| Feature        | SSR                  | SSG                 | ISR                       |
| -------------- | -------------------- | ------------------- | ------------------------- |
| HTML Generated | On each request      | At build time       | At build + periodic regen |
| Freshness      | Always fresh         | Stale until rebuild | Fresh after revalidate    |
| Speed          | Slower               | Fastest             | Fast                      |
| Server Load    | High                 | Low                 | Low                       |
| Best for       | Highly dynamic pages | Mostly static pages | Semi-dynamic content      |

---

### Interview Tip — Senior-Level

You should mention:

- **Hydration:** All three methods still hydrate React on the client side.
- **Trade-offs:** SSR gives freshness but costs performance; SSG gives speed but can be stale; ISR is a balance.
- **Use cases:**
  - SSR → User dashboards, search results.
  - SSG → Marketing pages, blogs.
  - ISR → News sites, e-commerce product pages.
