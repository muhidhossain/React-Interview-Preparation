## Data Fetching Libraries: React Query (TanStack Query), SWR

### Why use data fetching libraries instead of just fetch or axios?

When you use plain `fetch()` or `axios`, you usually have to manage:
- Loading states (`isLoading`)
- Error states (`error`)
- Caching responses
- Refetching data automatically
- Synchronizing UI with server state

Data fetching libraries like React Query and SWR solve these problems by:
- Handling caching automatically
- Avoiding unnecessary requests
- Keeping data fresh with background refetching
- Making state management for API calls almost zero-effort

---

### React Query (TanStack Query)

React Query is a server state management library.

**Key Features:**
- Automatic caching and background refetching.
- Stale-while-revalidate strategy.
- Works with REST, GraphQL, or any async data source.
- Retry failed requests automatically.
- Manual and automatic data refetch triggers.

**Installation:**

```bash
npm install @tanstack/react-query
```

**Setup:**

```jsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import App from './App';

const queryClient = new QueryClient();

export default function Root() {
	return (
		<QueryClientProvider client={queryClient}>
			<App />
		</QueryClientProvider>
	);
}
```

**Usage Example:**

```jsx
import { useQuery } from '@tanstack/react-query';
import axios from 'axios';

function Posts() {
	const { data, error, isLoading } = useQuery({
		queryKey: ['posts'], // cache key
		queryFn: () => axios.get('https://jsonplaceholder.typicode.com/posts').then(res => res.data)
	});

	if (isLoading) return <p>Loading...</p>;
	if (error) return <p>Error: {error.message}</p>;

	return (
		<ul>
			{data.map(post => <li key={post.id}>{post.title}</li>)}
		</ul>
	);
}

export default Posts;
```

---

### SWR

SWR (by Vercel) stands for Stale-While-Revalidate — a caching strategy where:
- You show cached data immediately (stale)
- Fetch new data in the background (revalidate)
- UI updates once fresh data arrives

**Key Features:**
- Minimal API
- Built-in caching
- Automatic revalidation on focus or network reconnect
- Suspense support

**Installation:**

```bash
npm install swr
```

**Usage Example:**

```jsx
import useSWR from 'swr';
import axios from 'axios';

// fetcher function
const fetcher = url => axios.get(url).then(res => res.data);

function Posts() {
	const { data, error, isLoading } = useSWR('https://jsonplaceholder.typicode.com/posts', fetcher);

	if (isLoading) return <p>Loading...</p>;
	if (error) return <p>Error loading posts</p>;

	return (
		<ul>
			{data.map(post => <li key={post.id}>{post.title}</li>)}
		</ul>
	);
}

export default Posts;
```

---

### React Query vs SWR

| Feature           | React Query (TanStack Query) | SWR        |
|-------------------|:---------------------------:|:----------:|
| Author            | Tanner Linsley              | Vercel     |
| Complexity        | More features (mutations, pagination, infinite queries) | Simpler API |
| Caching Strategy  | Stale-While-Revalidate (configurable) | Stale-While-Revalidate (built-in) |
| Mutations         | ✅ Built-in                 | ❌ Requires manual handling |
| Best For          | Complex apps with CRUD, pagination, background sync | Simple data fetching & caching |
| API Size          | Larger                      | Smaller    |

---

### When to choose which

- **Choose React Query** → You have complex server state, need mutations, pagination, or offline support.
- **Choose SWR** → You have a simple read-only API and want minimal setup.
