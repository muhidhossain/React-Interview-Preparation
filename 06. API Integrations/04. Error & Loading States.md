## Error & Loading States

### Loading States in React

**What it is:**
A "loading state" is a UI indicator that the app is waiting for something — usually data from an API or a computation.

**Why it’s important:**

- Gives users feedback that something is happening
- Prevents UI from feeling “frozen”
- Improves perceived performance

**Common Patterns:**

- Local `useState` flag
- Derived state from libraries like React Query, SWR, or Redux

**Example (Basic Loading State):**

```jsx
import { useState, useEffect } from 'react';

function Users() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('/api/users')
      .then((res) => res.json())
      .then((data) => {
        setUsers(data);
        setLoading(false);
      });
  }, []);

  if (loading) return <p>Loading...</p>;
  return users.map((u) => <p key={u.id}>{u.name}</p>);
}
```

**Better UX ideas for loading states:**

- Skeleton loaders (gray placeholders shaped like content)
- Spinners or progress bars
- Inline loaders for partial updates

---

### Error States in React

**What it is:**
A UI state shown when something goes wrong — API errors, network issues, validation failures, etc.

**Why it’s important:**

- Guides the user when something fails
- Prevents broken or confusing UIs
- Helps with debugging and error tracking

**Common Patterns:**

- Track error in local state
- Use try...catch with async functions
- Rely on library error handling (`isError` in React Query, for example)

**Example (Basic Error State):**

```jsx
import { useState, useEffect } from 'react';

function Users() {
  const [users, setUsers] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('/api/users')
      .then((res) => {
        if (!res.ok) throw new Error('Failed to fetch users');
        return res.json();
      })
      .then(setUsers)
      .catch((err) => setError(err.message));
  }, []);

  if (error) return <p style={{ color: 'red' }}>Error: {error}</p>;
  return users.map((u) => <p key={u.id}>{u.name}</p>);
}
```

---

### Loading + Error State Together

When fetching data, these states often work together:

**Possible flow:**

- `loading: true`, `error: null`
- Fetch request
- If success → loading becomes false, show data
- If failure → loading becomes false, error gets a message

**Example:**

```jsx
function Users() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchUsers() {
      try {
        const res = await fetch('/api/users');
        if (!res.ok) throw new Error('Failed to fetch users');
        const data = await res.json();
        setUsers(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    fetchUsers();
  }, []);

  if (loading) return <p>Loading...</p>;
  if (error) return <p style={{ color: 'red' }}>Error: {error}</p>;
  return users.map((u) => <p key={u.id}>{u.name}</p>);
}
```

---

### Using Libraries

Libraries like React Query simplify loading & error states because they’re built-in:

```jsx
import { useQuery } from '@tanstack/react-query';

function Users() {
  const { data, isLoading, isError, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then((res) => res.json()),
  });

  if (isLoading) return <p>Loading...</p>;
  if (isError) return <p style={{ color: 'red' }}>Error: {error.message}</p>;
  return data.map((u) => <p key={u.id}>{u.name}</p>);
}
```

---

### Good Practices

- Always show loading feedback for async actions
- Use friendly and actionable error messages (not just raw server text)
- Avoid UI flicker (don’t reset state unnecessarily during refetch)
- Use skeleton loaders for better UX instead of just spinners
