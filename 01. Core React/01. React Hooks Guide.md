# React Hooks Guide

## useState, useEffect, useContext, useRef, useMemo, useCallback

### useState

**Purpose:** Lets you add state to a functional component.

A React hook that lets you add state variables to functional components.
It returns an array with the current state value and a function to update it, causing a re-render when the state changes.

**Example:**

```javascript
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // state variable

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>➕ Increment</button>
    </div>
  );
}
```

**Real-world use case:**

- Tracking form inputs (name, email)
- Toggling UI components (sidebar open/close)
- Storing API response data after fetch

---

### useEffect

**Purpose:** Lets you perform side effects after rendering — fetching data, setting up subscriptions, manipulating the DOM, etc.

A React hook that lets you perform side effects in functional components, such as data fetching, subscriptions, or DOM manipulation.
It runs after the component renders and can optionally clean up before the next effect run.

**Example:**

```javascript
import React, { useEffect, useState } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetch(`/api/user/${userId}`)
      .then((res) => res.json())
      .then((data) => setUser(data));
  }, [userId]); // runs when userId changes

  return user ? <h1>{user.name}</h1> : <p>Loading...</p>;
}
```

**Real-world use case:**

- Fetching data when a page loads or when an ID changes
- Setting up WebSocket connections
- Running animations after a component mounts

---

### useContext

**Purpose:** Lets you access data from a React Context without passing props through every level.

A React hook that allows a functional component to read and subscribe to values from a React Context without passing props through the component tree.

**Example:**

```javascript
import React, { createContext, useContext } from 'react';

const ThemeContext = createContext('light');

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return (
    <button style={{ background: theme === 'dark' ? '#333' : '#fff' }}>
      Theme: {theme}
    </button>
  );
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

**Real-world use case:**

- App-wide theme (light/dark mode)
- Logged-in user information
- Language/locale settings

---

### useRef

**Purpose:**

- Create a mutable reference that doesn't trigger re-renders when changed
- Access DOM elements directly

A React hook that returns a mutable object with a `.current` property.
The `.current` value persists across renders without triggering a re-render when updated, and it can also be used to access DOM elements directly.

**Example:**

```javascript
import React, { useRef } from 'react';

function FocusInput() {
  const inputRef = useRef();

  const handleFocus = () => {
    inputRef.current.focus();
  };

  return (
    <>
      <input ref={inputRef} placeholder="Click button to focus me" />
      <button onClick={handleFocus}>Focus Input</button>
    </>
  );
}
```

**Real-world use case:**

- Storing previous state without causing re-renders
- Controlling focus, scrolling, or media playback
- Keeping reference to a timer ID

---

### useMemo

**Purpose:**
Memoizes the result of a calculation so it's not recalculated on every render unless dependencies change.

A React hook that memoizes a computed value, re-computing it only when one of its dependencies changes.
It helps optimize performance by avoiding expensive recalculations on every render.

**Example:**

```javascript
import React, { useMemo, useState } from 'react';

function ExpensiveCalculation({ number }) {
  const result = useMemo(() => {
    console.log('Calculating...');
    return number * 2; // Imagine this takes 2s
  }, [number]);

  return <p>Result: {result}</p>;
}

function App() {
  const [num, setNum] = useState(1);
  const [count, setCount] = useState(0);

  return (
    <>
      <ExpensiveCalculation number={num} />
      <button onClick={() => setNum(num + 1)}>Change Num</button>
      <button onClick={() => setCount(count + 1)}>Re-render</button>
    </>
  );
}
```

**Real-world use case:**

- Avoid recalculating filtered lists or sorted data unless input changes
- Performance optimization in large datasets or expensive computations

---

### useCallback

**Purpose:**
Memoizes a function so it's not recreated on every render unless dependencies change (useful when passing functions to child components that depend on referential equality).

A React hook that memoizes a function, returning the same function reference unless its dependencies change.
It is used to prevent unnecessary re-renders in components that rely on referential equality.

**Example:**

```javascript
import React, { useState, useCallback } from 'react';

function Child({ onClick }) {
  console.log('Child rendered');
  return <button onClick={onClick}>Click Me</button>;
}

function App() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    console.log('Clicked!');
  }, []); // function reference stays same

  return (
    <>
      <Child onClick={handleClick} />
      <button onClick={() => setCount(count + 1)}>Re-render Parent</button>
    </>
  );
}
```

**Real-world use case:**

- Prevent unnecessary re-renders in memoized child components
- Passing stable function references to components like React.memo or event handlers

---

## Summary Table

| Hook        | Purpose                                   | Main Use Case                             |
| ----------- | ----------------------------------------- | ----------------------------------------- |
| useState    | Store and update state                    | Form fields, counters, toggles            |
| useEffect   | Handle side effects                       | Data fetching, subscriptions, DOM updates |
| useContext  | Access global data without props drilling | Theme, auth, settings                     |
| useRef      | Store mutable value or access DOM         | Focus input, store timers                 |
| useMemo     | Cache computed value                      | Expensive calculations, filtered lists    |
| useCallback | Cache function reference                  | Prevent child re-renders                  |
