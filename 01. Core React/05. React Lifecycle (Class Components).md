# React Lifecycle (for Class Components)

In React class components, the lifecycle refers to the sequence of methods React automatically calls during a component's existence — from creation to update to removal from the DOM.

It's like the "life story" of your component — born, living, and eventually dying — and you get hooks (lifecycle methods) to run your own code at each stage.

![React Component Lifecycle](../assets/react_component_lifecycle.jpg)

## Three Main Phases

### 1. Mounting (Component is being created and inserted into the DOM)

Methods called once when the component is first rendered:

| Method                                          | Purpose                                                                                         |
| ----------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| `constructor(props)`                            | Initialize state, bind methods. Avoid heavy logic here.                                         |
| `static getDerivedStateFromProps(props, state)` | Sync state with props before rendering. Rarely used.                                            |
| `render()`                                      | Returns JSX to display. Pure function (no side effects).                                        |
| `componentDidMount()`                           | Runs after the component is mounted. Good for API calls, event listeners, or DOM manipulations. |

**Example (Mounting):**

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { data: null };
  }

  componentDidMount() {
    fetch('/api/data')
      .then((res) => res.json())
      .then((data) => this.setState({ data }));
  }

  render() {
    return <div>{this.state.data || 'Loading...'}</div>;
  }
}
```

### 2. Updating (Component re-renders due to state/props changes)

Called every time props or state changes.

| Method                                               | Purpose                                                                              |
| ---------------------------------------------------- | ------------------------------------------------------------------------------------ |
| `static getDerivedStateFromProps()`                  | Sync state with new props before rendering.                                          |
| `shouldComponentUpdate(nextProps, nextState)`        | Optimize performance by preventing unnecessary re-renders (return false to skip).    |
| `render()`                                           | Returns updated JSX.                                                                 |
| `getSnapshotBeforeUpdate(prevProps, prevState)`      | Capture some info (like scroll position) before DOM updates.                         |
| `componentDidUpdate(prevProps, prevState, snapshot)` | Runs after DOM update. Good for reacting to changes (e.g., API call on prop change). |

**Example (Updating):**

```jsx
componentDidUpdate(prevProps) {
  if (prevProps.userId !== this.props.userId) {
    this.fetchUserData();
  }
}
```

### 3. Unmounting (Component is removed from the DOM)

| Method                   | Purpose                                                                    |
| ------------------------ | -------------------------------------------------------------------------- |
| `componentWillUnmount()` | Cleanup work: remove event listeners, cancel API calls, clear timers, etc. |

**Example (Unmounting):**

```jsx
componentWillUnmount() {
  clearInterval(this.timer);
  window.removeEventListener('resize', this.handleResize);
}
```

## React Lifecycle Diagram (Class Components)

```
MOUNTING:
constructor → getDerivedStateFromProps → render → componentDidMount

UPDATING:
getDerivedStateFromProps → shouldComponentUpdate → render → getSnapshotBeforeUpdate → componentDidUpdate


**UNMOUNTING:**
componentWillUnmount
```

## Key Points

- **Mounting** → Setup (state, API calls)
- **Updating** → React to changes
- **Unmounting** → Cleanup
- Lifecycle methods are only available in class components (hooks replace them in function components).
- Using too many lifecycle methods for side effects can make components hard to maintain — hooks provide more granular control.

## Complete Lifecycle Example

```jsx
class LifecycleDemo extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
      data: null,
    };
    console.log('Constructor called');
  }

  static getDerivedStateFromProps(props, state) {
    console.log('getDerivedStateFromProps called');
    return null; // No state update needed
  }

  componentDidMount() {
    console.log('componentDidMount called');
    // Setup: API calls, event listeners, timers
    this.timer = setInterval(() => {
      this.setState((prevState) => ({ count: prevState.count + 1 }));
    }, 1000);
  }

  shouldComponentUpdate(nextProps, nextState) {
    console.log('shouldComponentUpdate called');
    // Optimize: prevent unnecessary re-renders
    return nextState.count !== this.state.count;
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    console.log('getSnapshotBeforeUpdate called');
    // Capture info before DOM update
    return { scrollPosition: window.scrollY };
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log('componentDidUpdate called', snapshot);
    // React to changes
    if (this.state.count === 10) {
      console.log('Count reached 10!');
    }
  }

  componentWillUnmount() {
    console.log('componentWillUnmount called');
    // Cleanup: clear timers, remove listeners
    clearInterval(this.timer);
  }

  render() {
    console.log('Render called');
    return (
      <div>
        <h1>Count: {this.state.count}</h1>
        <button onClick={() => this.setState({ count: 0 })}>Reset</button>
      </div>
    );
  }
}
```

## Modern Alternative: React Hooks

In modern React (function components), lifecycle methods are replaced by hooks:

- `componentDidMount` → `useEffect(() => {}, [])`
- `componentDidUpdate` → `useEffect(() => {})`
- `componentWillUnmount` → `useEffect(() => { return () => {} }, [])`

```jsx
// Hook equivalent of the above class component
function HookDemo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // componentDidMount + componentDidUpdate
    console.log('Effect runs');

    const timer = setInterval(() => {
      setCount((prev) => prev + 1);
    }, 1000);

    // componentWillUnmount (cleanup)
    return () => {
      console.log('Cleanup');
      clearInterval(timer);
    };
  }, []); // Empty dependency array = only on mount/unmount

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}
```
