# Lifting State Up

**Lifting State Up** in React means moving a piece of state from a child component to a common parent so that multiple components can share and synchronize the same data.

Instead of each child managing its own state separately, the parent manages the state and passes it down via props.

## Why Do We Need It?

- To avoid duplication of state in multiple components.
- To keep data consistent across components.
- To make it easier to manage and debug state.

## Example: Without Lifting State Up

Here's a problem: We have two components — one takes temperature in Celsius, the other in Fahrenheit — but they don't update each other.

```javascript
function CelsiusInput() {
  const [celsius, setCelsius] = React.useState('');

  return (
    <div>
      <label>Celsius: </label>
      <input value={celsius} onChange={(e) => setCelsius(e.target.value)} />
    </div>
  );
}

function FahrenheitInput() {
  const [fahrenheit, setFahrenheit] = React.useState('');

  return (
    <div>
      <label>Fahrenheit: </label>
      <input
        value={fahrenheit}
        onChange={(e) => setFahrenheit(e.target.value)}
      />
    </div>
  );
}

export default function App() {
  return (
    <>
      <CelsiusInput />
      <FahrenheitInput />
    </>
  );
}
```

**Problem**: Changing Celsius doesn't update Fahrenheit and vice versa.

## Example: With Lifting State Up

We move the temperature state into a common parent, so both inputs share the same source of truth.

```javascript
function TemperatureInput({ value, onChange, label }) {
  return (
    <div>
      <label>{label}: </label>
      <input value={value} onChange={(e) => onChange(e.target.value)} />
    </div>
  );
}

export default function App() {
  const [temperature, setTemperature] = React.useState('');
  const [scale, setScale] = React.useState('c');

  const toCelsius = (f) => ((f - 32) * 5) / 9;
  const toFahrenheit = (c) => (c * 9) / 5 + 32;

  const celsius = scale === 'f' ? toCelsius(Number(temperature)) : temperature;
  const fahrenheit =
    scale === 'c' ? toFahrenheit(Number(temperature)) : temperature;

  return (
    <>
      <TemperatureInput
        label="Celsius"
        value={celsius}
        onChange={(value) => {
          setScale('c');
          setTemperature(value);
        }}
      />
      <TemperatureInput
        label="Fahrenheit"
        value={fahrenheit}
        onChange={(value) => {
          setScale('f');
          setTemperature(value);
        }}
      />
    </>
  );
}
```

## How It Works

1. The state (`temperature` and `scale`) is now in `App` (the parent).
2. `App` passes:

   - The value (temperature in correct units)
   - The onChange handler

   to each `TemperatureInput`.

3. When a user types in one input, the parent updates its state, recalculates, and sends new props to both inputs.

## Benefits:

- Single source of truth for data.
- No duplication of state logic.
- Changes in one place automatically reflect everywhere.
