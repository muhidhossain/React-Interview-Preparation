# Error Boundaries

In React, an **Error Boundary** is a special kind of component that catches JavaScript errors anywhere in its child component tree (during rendering, in lifecycle methods, and in constructors of child components) and prevents the whole React app from crashing.

Instead, it can display a fallback UI (like an error message or alternative component).

Think of it like a "circuit breaker" for UI errors.

## Why do we need Error Boundaries?

**Without error boundaries:**

- If a component throws an error during rendering, React will unmount the entire component tree.
- The user might see a blank white screen (bad experience).
- We want the app to fail gracefully.

## Rules & Limitations

**Error Boundaries only catch errors in:**

- Render methods
- Lifecycle methods
- Constructors of the component tree below them

**They do not catch errors in:**

- Event handlers (you need `try...catch` for those)
- Asynchronous code (`setTimeout`, `fetch`)
- Server-side rendering
- Errors thrown inside the error boundary itself

## How to Create an Error Boundary

Error Boundaries are class components (as of now) because they rely on lifecycle methods.

### Example

```jsx
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  // This lifecycle method catches the error and updates state
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  // This lifecycle method logs the error details
  componentDidCatch(error, errorInfo) {
    console.error('Error caught by ErrorBoundary:', error, errorInfo);
    // You could send error details to an error tracking service here
  }

  render() {
    if (this.state.hasError) {
      // Render a fallback UI
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

export default ErrorBoundary;
```

## Using the Error Boundary

Wrap it around components that might fail:

```jsx
import ErrorBoundary from './ErrorBoundary';
import MyComponent from './MyComponent';

function App() {
  return (
    <div>
      <ErrorBoundary>
        <MyComponent />
      </ErrorBoundary>
    </div>
  );
}
```

If `MyComponent` throws an error during rendering, the error boundary will catch it and show "Something went wrong" instead of breaking the whole app.

## Best Practices

1. **Place Error Boundaries strategically** — not just at the root.

   Example:

   - One around the entire app (for uncaught errors)
   - One around risky areas (e.g., a chart component that depends on API data)

2. **Use different fallback UIs for different areas:**

   - Dashboard → "Unable to load dashboard data"
   - Form → "Form failed to load. Please refresh"

3. **Send error logs to an external service** (e.g., Sentry, LogRocket).

## Handling in Function Components

React doesn't support error boundaries as hooks yet.
But you can wrap function components inside a class-based error boundary.

## In short:

**Error Boundaries = React's way to catch and handle runtime rendering errors gracefully so your app doesn't crash into a white screen.**
