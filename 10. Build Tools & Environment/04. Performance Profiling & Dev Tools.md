## Performance Profiling & Dev Tools

### What is Performance Profiling in React?

Performance profiling is the process of measuring, analyzing, and optimizing how your React app renders and updates to ensure it runs smoothly.

**Goal:** Identify slow renders, unnecessary re-renders, and heavy computations.

**Tools:** React DevTools Profiler + Browser DevTools.

---

### React DevTools Overview

React DevTools is a browser extension (Chrome, Firefox) that adds two important tabs in the DevTools panel:

#### ⚛️ Components tab

- View the component tree
- Inspect props and state
- See hooks values
- Debug why a component renders

#### ⚡ Profiler tab

- Record render timings
- See flamegraph of component updates
- Identify wasted renders

---

### Performance Profiling with React DevTools

**Steps in the Profiler:**

1. Open Profiler tab (Chrome DevTools → React → Profiler).
2. Start recording (click the Record button ⏺️).
3. Interact with the app (trigger actions that may cause re-renders).
4. Stop recording (click the Stop button ⏹️).
5. Analyze results:
   - **Flamegraph view:** Shows render duration of each component.
   - **Ranked view:** Components sorted by render time.

**Key Metrics in Profiler:**

- Render time → How long a component took to render.
- Commit time → How long React took to update the DOM.
- Re-render frequency → If a component updates more than needed.

---

### Browser DevTools for Performance

#### Chrome DevTools Performance Tab

- Record JavaScript execution and paint events.
- Detect:
  - Long-running JS tasks
  - Layout shifts
  - FPS drops

#### Network Tab

- Check asset loading times, large JS bundles.
- Detect unnecessary re-fetching of data.

#### Memory Tab

- Find memory leaks (e.g., components not unmounting properly).

---

### Common Performance Issues in React

- Unnecessary re-renders due to:
  - Passing new object/array props each time
  - Not memoizing functions (missing useCallback)
  - Overuse of context causing large subtree updates
  - Expensive computations in render
- Large initial bundle size (slow first load)
- Blocking UI with heavy synchronous code

---

### Optimization Strategies

✅ **Memoization** - `React.memo` → Prevents re-render if props are the same. - `useCallback` → Memoizes functions. - `useMemo` → Memoizes computed values.

✅ **Code Splitting** - `React.lazy` + `Suspense` for lazy loading.

✅ **Virtualization** - `react-window`, `react-virtualized` for large lists.

✅ **Avoid Inline Functions/Objects** - Move them outside render or memoize.

✅ **Efficient State Management** - Keep state as local as possible. - Avoid lifting state unnecessarily.

---

### Sample Interview Questions

- How do you detect unnecessary re-renders in a React app?
- What’s the difference between Flamegraph and Ranked views in React Profiler?
- How can you reduce the initial load time of a React app?
- What causes slow renders in React?
- How do React.memo and useCallback help in performance?
- What’s the difference between measuring performance in React Profiler vs Chrome Performance tab?
- How do you find and fix a memory leak in React?

---

### Quick Example

```jsx
import React, { useState, useCallback } from 'react';

const Button = React.memo(({ onClick }) => {
  console.log('Button rendered');
  return <button onClick={onClick}>Click</button>;
});

export default function App() {
  const [count, setCount] = useState(0);
  const increment = useCallback(() => setCount((c) => c + 1), []);
  return (
    <>
      <p>{count}</p>
      <Button onClick={increment} />
    </>
  );
}
```

_Without useCallback, Button would re-render every time App renders._
