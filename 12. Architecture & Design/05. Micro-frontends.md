## Micro-frontends

### What Are Micro-frontends?

Micro-frontends apply the microservices architecture concept to the frontend.
Instead of one large React app (monolith), the UI is split into independent, self-contained frontend applications that:

- Are developed, deployed, and scaled independently
- Can be built with different frameworks (React, Angular, Vue, etc.) if needed
- Communicate and integrate at runtime to form a single user experience

---

### Why Use Micro-frontends?

**Problems with large frontend monoliths:**

- Hard to scale teams without stepping on each other’s code
- Long build/deploy times
- Risky deployments — a bug anywhere can break the whole app
- Different teams may want different tech stacks or release cycles

**Micro-frontend benefits:**

- Team autonomy — Each team owns its feature end-to-end (code, build, deploy)
- Independent deployments — Faster release cycles
- Tech diversity — Different micro-apps can use different frameworks/versions
- Gradual upgrades — Can migrate from old tech (e.g., AngularJS → React) piece by piece

---

### Key Concepts for Senior Engineers

**Composition at runtime**
How the pieces come together:

- Server-side composition (HTML assembled at backend before sending to browser)
- Client-side composition (JavaScript loads and mounts micro-apps in the browser)
- Edge-side composition (CDN level assembly)

**Isolation**

- Code isolation (no shared global state unless explicitly designed)
- Style isolation (CSS modules, CSS-in-JS, Shadow DOM)

**Routing strategies**

- Each micro-app handles its own routes
- A root app/router coordinates which micro-app loads

**Shared dependencies**

- Avoid bundling React multiple times — use Module Federation to share
- Control dependency versions to avoid conflicts

---

### How React Fits In

React is often used in each micro-frontend because:

- It’s component-based (easy to scope features)
- Works well with Webpack Module Federation for runtime integration
- React Router can integrate with a root router for navigation

---

### Example — Module Federation with React

Imagine we have:

- `app-shell` — Root container (navigation, layout)
- `product-app` — React app showing products
- `cart-app` — React app showing cart

**Webpack config for product-app:**

```js
// product-app/webpack.config.js
new ModuleFederationPlugin({
  name: 'productApp',
  filename: 'remoteEntry.js',
  exposes: {
    './ProductList': './src/components/ProductList',
  },
  shared: { react: { singleton: true }, 'react-dom': { singleton: true } },
});
```

**app-shell consuming it:**

```js
// app-shell/App.js
import ProductList from 'productApp/ProductList';

function App() {
  return (
    <div>
      <Header />
      <ProductList />
    </div>
  );
}
```

This way, `ProductList` is fetched at runtime from product-app’s build.

---

### Challenges (Interview Depth)

- **Performance:** Too many network calls if each micro-app loads separately
  - _Mitigation:_ Use bundling strategies, prefetch/preload, SSR.
- **Consistency:** Design system & UX must remain consistent across micro-apps
  - _Mitigation:_ Shared UI library via npm or monorepo package.
- **State management:** Cross-app state (e.g., auth) is tricky
  - _Mitigation:_ Use global events, URL state, or shared store (Zustand, Redux) in a central app.
- **Dependency duplication:** Each micro-app may ship its own React version
  - _Mitigation:_ Module Federation shared config.

---

### Senior-Level Interview Questions You Might Get

- When would you choose micro-frontends over a monolith in React?
- How would you share state between micro-frontends?
- Explain how Module Federation works in a micro-frontend React architecture.
- What are the trade-offs of client-side vs server-side composition?
- How would you ensure design consistency across independently deployed React apps?
- How do you handle version mismatches in shared dependencies like React?
