## Mocking APIs with MSW

### What is MSW?

MSW (Mock Service Worker) is a library that intercepts network requests in both:

- **Tests** → via a mocked service worker in Node
- **Browser development** → via a real service worker

Instead of stubbing fetch or Axios manually, you:

- Define handlers that mimic API responses
- Let MSW intercept the requests and return your fake data
- Keep tests close to real API behavior

**Why it’s better than Jest fetch mocks:**

- Simulates real HTTP layer (URLs, methods, headers)
- Works in browser and Node environments
- Reusable mock logic between dev and tests

---

### Installation

```bash
npm install msw --save-dev
```

---

### Setting up MSW for Testing

**Step 1 — Create your handlers**

```js
// src/mocks/handlers.js
import { rest } from 'msw';

export const handlers = [
  rest.get('/api/users', (req, res, ctx) => {
    return res(ctx.status(200), ctx.json(['Alice', 'Bob']));
  }),

  rest.post('/api/login', (req, res, ctx) => {
    const { username } = req.body;
    return res(ctx.status(200), ctx.json({ message: `Welcome, ${username}!` }));
  }),
];
```

**Step 2 — Set up the mock server for tests**

```js
// src/mocks/server.js
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

// Create server with handlers
export const server = setupServer(...handlers);
```

**Step 3 — Add global test lifecycle hooks**

```js
// src/setupTests.js
import { server } from './mocks/server';
import '@testing-library/jest-dom';

// Start server before all tests
beforeAll(() => server.listen());

// Reset handlers between tests to avoid test pollution
afterEach(() => server.resetHandlers());

// Close server after all tests
afterAll(() => server.close());
```

(In package.json, ensure jest is configured to use setupTests.js)

---

### Example Component Using API

```jsx
// UserList.js
import { useEffect, useState } from 'react';

export default function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('/api/users')
      .then((res) => res.json())
      .then((data) => {
        setUsers(data);
        setLoading(false);
      });
  }, []);

  if (loading) return <p>Loading...</p>;

  return (
    <ul>
      {users.map((user) => (
        <li key={user}>{user}</li>
      ))}
    </ul>
  );
}
```

---

### Test with MSW Mock

```js
// UserList.test.js
import { render, screen } from '@testing-library/react';
import UserList from './UserList';

test('loads and displays users', async () => {
  render(<UserList />);

  // Loading state
  expect(screen.getByText(/loading/i)).toBeInTheDocument();

  // Wait for mocked API to resolve
  const alice = await screen.findByText('Alice');
  const bob = screen.getByText('Bob');

  expect(alice).toBeInTheDocument();
  expect(bob).toBeInTheDocument();
});
```

---

### Overriding Mock for Specific Tests

You can override handlers inside a single test:

```js
import { rest } from 'msw';
import { server } from './mocks/server';

test('handles server error', async () => {
  server.use(rest.get('/api/users', (req, res, ctx) => res(ctx.status(500))));

  render(<UserList />);
  const errorMessage = await screen.findByText(/error/i);
  expect(errorMessage).toBeInTheDocument();
});
```

---

### Key advantages of MSW:

- No need to rewrite mocks in each test
- Works in both tests and browser dev
- More realistic than stubbing fetch manually
