## Component Testing

### What is Component Testing?

**Definition:**
Testing a single, complete component in isolation to ensure it renders and behaves correctly given specific inputs and interactions.

**Think of it as:**

- Unit testing → testing small, focused functions or hooks
- Component testing → testing a self-contained UI element (with or without child components)
- Integration testing → testing multiple components/services together

In React, component testing often involves:

- Rendering the component in a virtual DOM (via React Testing Library or Enzyme)
- Passing props and checking output
- Simulating user events
- Asserting DOM changes or callback calls

---

### Why Component Testing?

- Detects UI bugs early
- Ensures UI behaves as expected when props/state change
- Acts as living documentation
- Safer refactoring

---

### Tools for Component Testing

- **Jest** → test runner + assertion library
- **React Testing Library (RTL)** → rendering, querying, interacting with DOM
- Optional: **MSW (Mock Service Worker)** for mocking APIs in component tests

---

### Example – Basic Component Test

```jsx
// Button.js
export default function Button({ onClick, label }) {
  return <button onClick={onClick}>{label}</button>;
}

// Button.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import Button from './Button';

test('renders with label and responds to click', () => {
  const handleClick = jest.fn();

  render(<Button onClick={handleClick} label="Click Me" />);

  // Check render
  expect(screen.getByText(/click me/i)).toBeInTheDocument();

  // Simulate click
  fireEvent.click(screen.getByText(/click me/i));

  // Check callback
  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

**What’s happening:**

- Render: RTL creates a virtual DOM version of `<Button />`.
- Query: `screen.getByText` finds elements as a user would.
- Interact: `fireEvent.click` simulates a click.
- Assert: Jest checks expectations.

---

### Example – Component with State & Child Elements

```jsx
// Counter.js
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
    </div>
  );
}

// Counter.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import Counter from './Counter';

test('increments counter when button clicked', () => {
  render(<Counter />);
  const button = screen.getByRole('button', { name: /increment/i });

  fireEvent.click(button);

  expect(screen.getByText(/count: 1/i)).toBeInTheDocument();
});
```

---

### Tips for Component Testing

- **Test behavior, not implementation**
  - ❌ Checking internal state variables
  - ✅ Checking what the user sees/experiences
- **Mock APIs for isolation**
  - Use Jest or MSW to avoid hitting real endpoints
- **Keep tests small & focused**
  - One behavior per test case
- **Use `userEvent` instead of `fireEvent`**
  - `userEvent` simulates more realistic user interactions (e.g., typing delay, tab focus)

---

### Where Component Testing Fits

In a testing pyramid:

- **Unit tests** → Many, small, fast
- **Component tests** → Fewer, verify user-facing features
- **End-to-end tests** → Fewest, full app flow
