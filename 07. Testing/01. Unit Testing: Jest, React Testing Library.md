## Unit Testing: Jest, React Testing Library

### Unit Testing Basics

**Purpose:** Test individual units (functions, components, hooks) in isolation to ensure they work as intended.

**Why:** Prevent regressions, improve confidence when refactoring, and document expected behavior.

**Example unit:**

- A function that formats a date.
- A React component that renders based on props.

---

### Jest

**What it is**
Jest is a JavaScript testing framework developed by Facebook. It’s an all-in-one solution for:

- Running tests
- Providing assertions
- Generating code coverage reports
- Mocking functions and modules

**Key features:**

- Zero configuration for most JS/React projects
- Built-in mocking capabilities
- Snapshot testing

**Example:**

```js
// sum.js
export function sum(a, b) {
  return a + b;
}

// sum.test.js
import { sum } from './sum';

test('adds two numbers correctly', () => {
  expect(sum(2, 3)).toBe(5);
});
```

**Jest CLI:**

```bash
npx jest
```

or in package.json:

```json
"scripts": {
	"test": "jest"
}
```

---

### React Testing Library (RTL)

**What it is**
RTL is a library for testing React components by focusing on how the user interacts with them, rather than their internal implementation.

**Core philosophy:**

> The more your tests resemble how your software is used, the more confidence they can give you.

**Key features:**

- Queries for elements the way a user would find them (`getByText`, `getByRole`, etc.)
- Encourages writing tests that focus on behavior, not implementation details.
- Works well with Jest for assertions and mocking.

**Example:**

```jsx
// Greeting.js
export default function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}

// Greeting.test.js
import { render, screen } from '@testing-library/react';
import Greeting from './Greeting';

test('renders greeting message', () => {
  render(<Greeting name="Muhid" />);
  const greetingElement = screen.getByText(/hello, muhid/i);
  expect(greetingElement).toBeInTheDocument();
});
```

---

### Jest + RTL Workflow

1. Write component → `Button.js`
2. Write test → `Button.test.js`
3. Render with RTL → `render(<Button />)`
4. Query elements → `screen.getByRole('button')`
5. Assert with Jest → `expect(element).toBeDisabled()`
6. Run tests → `npm test`

---

### Common Patterns

**Event simulation**

```jsx
import { render, screen, fireEvent } from '@testing-library/react';
import Counter from './Counter';

test('increments count on click', () => {
  render(<Counter />);
  const button = screen.getByRole('button', { name: /increment/i });
  fireEvent.click(button);
  expect(screen.getByText(/count: 1/i)).toBeInTheDocument();
});
```

**Mocking API calls**

```js
global.fetch = jest.fn(() =>
  Promise.resolve({
    json: () => Promise.resolve({ data: 'Hello' }),
  })
);
```

**Snapshot testing**

```js
import { render } from '@testing-library/react';
import Greeting from './Greeting';

test('matches snapshot', () => {
  const { asFragment } = render(<Greeting name="Muhid" />);
  expect(asFragment()).toMatchSnapshot();
});
```

---

### In short:

- **Jest:** Testing framework → runs the tests, provides assertions, mocks.
- **React Testing Library:** Utility → renders React components, queries DOM like a user would, simulates interactions.
- **Together** → They form the main testing setup for most modern React apps.
