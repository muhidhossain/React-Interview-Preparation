## Snapshot Testing

### What is Snapshot Testing?

Snapshot testing is a way to capture the rendered output of a component and store it in a file. On subsequent test runs, Jest compares the current output to the stored snapshot to detect changes.

**Think of it as:**

> “Freeze” the component’s UI now → alert me if it changes later.

---

### How it Works

1. Render a component (e.g., with React Testing Library)
2. Save its rendered HTML structure to a `.snap` file
3. On future runs, Jest checks if the new render matches the stored snapshot
4. If changes are intentional → update snapshot with `-u` flag (`jest -u`)

---

### Example

```jsx
// Greeting.js
export default function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}

// Greeting.test.js
import { render } from '@testing-library/react';
import Greeting from './Greeting';

test('matches snapshot', () => {
  const { asFragment } = render(<Greeting name="Muhid" />);
  expect(asFragment()).toMatchSnapshot();
});
```

**First run generates a file:**
`__snapshots__/Greeting.test.js.snap`

**Example snapshot file:**

```js
// Jest Snapshot v1
exports[`matches snapshot 1`] = `
<DocumentFragment>
	<h1>
		Hello, Muhid!
	</h1>
</DocumentFragment>
`;
```

---

### When to Use Snapshot Testing

✅ **Good for:**

- Static UI that changes rarely (icons, layout wrappers, small presentational components)
- Detecting accidental UI changes during refactors
- Documenting default component output

❌ **Avoid for:**

- Large, dynamic components (snapshots become hard to read)
- Testing logic-heavy components (better to assert specific DOM changes)

---

### Updating Snapshots

If your UI change is intentional:

```bash
npm test -- -u
# or
jest -u
```

---

### Best Practices

- Keep snapshots small and focused → big snapshots are unreadable.
- Pair snapshots with explicit assertions for key behaviors.
- Use descriptive test names → "renders default button" not "matches snapshot".
- Avoid relying only on snapshots for correctness.
