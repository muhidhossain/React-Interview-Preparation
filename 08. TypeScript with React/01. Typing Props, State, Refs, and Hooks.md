## Typing Props, State, Refs, and Hooks

### Typing Props

Props are inputs to components. In TypeScript, you define a type or interface for them.

**Example:**

```tsx
type ButtonProps = {
  label: string;
  onClick?: () => void; // optional
};

const Button: React.FC<ButtonProps> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};

// Usage
<Button label="Click me" onClick={() => console.log('Clicked')} />;
```

**Interview Tip:**

- Use `type` or `interface` for props.
- Mark optional props with `?`.
- Avoid `React.FC<Props>` if you want to explicitly type `children` yourself (because `React.FC` includes `children` by default).

---

### Typing State

You use `useState` with generic type arguments or inferred types.

**Example:**

```tsx
// Explicit typing
const [count, setCount] = React.useState<number>(0);

// Type inferred from initial value (good for most cases)
const [name, setName] = React.useState('John');

// Union type
const [status, setStatus] = React.useState<'idle' | 'loading' | 'error'>(
  'idle'
);
```

**Interview Tip:**

- Use union types for state that can have multiple allowed values.
- Explicit typing is needed when the initial value is `null` or `undefined`.

---

### Typing Refs

Refs are used for DOM elements or mutable values.

**Example:**

```tsx
// DOM element ref
const inputRef = React.useRef<HTMLInputElement>(null);

// Mutable value ref
const intervalId = React.useRef<number | null>(null);

// Accessing DOM ref safely
React.useEffect(() => {
  if (inputRef.current) {
    inputRef.current.focus();
  }
}, []);
```

**Interview Tip:**

- Use `React.RefObject<T>` for refs returned by `useRef`.
- For DOM elements, use the specific element type like `HTMLDivElement`, `HTMLInputElement`.

---

### Typing Hooks

When you create custom hooks, type the parameters, return values, and state inside.

**Example:**

```tsx
function useCounter(initialValue: number = 0) {
  const [count, setCount] = React.useState<number>(initialValue);

  const increment = () => setCount((c) => c + 1);
  const decrement = () => setCount((c) => c - 1);

  return { count, increment, decrement };
}

// Usage
const { count, increment } = useCounter(5);
```

**Interview Tip:**

- Custom hooks should be typed for parameters and return values explicitly.
- Generics are useful for reusable hooks.

---

### Quick Typing Reference Table

| Feature            | Example Type                                | Notes                             |
| ------------------ | ------------------------------------------- | --------------------------------- |
| Props              | `type Props = { name: string }`             | Use type or interface             |
| State              | `useState<number>(0)`                       | Needed for null or complex unions |
| Refs               | `useRef<HTMLInputElement>(null)`            | DOM or mutable values             |
| Custom Hook Params | `(initial: number)`                         | Type arguments + defaults         |
| Custom Hook Return | `(): { value: number; setValue: Function }` | Explicit for clarity              |
