## Generics in Components and Hooks

### What are Generics?

Generics let you write reusable, type-safe code that works with different types without losing type information.
Think of them as placeholders for a type that gets filled when you use the function, hook, or component.

**Example of a generic in plain TypeScript:**

```ts
function identity<T>(value: T): T {
  return value;
}

const num = identity<number>(5); // T = number
const str = identity('hello'); // T inferred as string
```

---

### Generics in React Components

You can create components that adapt to different data types.

**Example: Generic List Component**

```tsx
type ListProps<T> = {
	items: T[];
	renderItem: (item: T) => React.ReactNode;
};

function List<T>({ items, renderItem }: ListProps<T>) {
	return <ul>{items.map((item, i) => <li key={i}>{renderItem(item)}</li>)}</ul>;
}

// Usage:
<List<number>
	items={[1, 2, 3]}
	renderItem={(num) => <strong>{num}</strong>}
/>

<List<{ id: number; name: string }>
	items={[{ id: 1, name: "John" }]}
	renderItem={(user) => <span>{user.name}</span>}
/>
```

**Interview Notes:**

- Generics allow reusability without losing type safety.
- Can be explicit (`<number>`) or inferred.

---

### Generics in React Hooks

Custom hooks often need to work with flexible data shapes.

**Example: useFetch Hook**

```tsx
function useFetch<T>(url: string) {
  const [data, setData] = React.useState<T | null>(null);
  const [error, setError] = React.useState<string | null>(null);

  React.useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then((json: T) => setData(json))
      .catch((err) => setError(err.message));
  }, [url]);

  return { data, error };
}

// Usage:
type User = { id: number; name: string };

const { data: users } = useFetch<User[]>('/api/users');
```

**Interview Notes:**

- `<T>` lets you pass the expected data type when calling the hook.
- Helps avoid `any` and enables IntelliSense.

---

### Generics with Default Types

You can give a fallback type if none is specified.

```tsx
function useArray<T = number>(initial: T[]) {
  const [array, setArray] = React.useState<T[]>(initial);
  return { array, setArray };
}

// Usage:
const { array } = useArray(); // array: number[]
const { array: strArray } = useArray<string>(['a', 'b']); // array: string[]
```

---

### Constraints in Generics

You can restrict what types are allowed.

```tsx
function useEntity<T extends { id: number }>(entities: T[]) {
  return entities.map((e) => e.id);
}

// Works
useEntity([{ id: 1, name: 'John' }]);
// ❌ Error: missing id
useEntity([{ name: 'John' }]);
```

---

### Key Interview Takeaways

- **Why Generics?** → Reusability + Type Safety.
- **Where used?** → Reusable UI components, data fetching hooks, form handlers.
- **Constraints (`extends`)** → Limit acceptable types.
- **Defaults (`<T = DefaultType>`)** → Avoid always specifying type.
